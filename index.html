<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N1X | CYBORG_CREATOR</title>

  <!-- Tailwind CSS CDN -->

  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React & ReactDOM from unpkg -->

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel Standalone for JSX -->

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* ============================================
       FONTS - Retro terminal aesthetic
       ============================================ */
    @import url('https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');
    
    /* ============================================
       CSS VARIABLES - Easy color customization
       ============================================ */
    :root {
      --matrix-green: #00ff41;
      --neon-cyan: #00ffff;
      --glitch-red: #ff0051;
      --glitch-purple: #b300ff;
      --bg-black: #000000;
      --bg-dark: #0a0a0a;
      --terminal-text: #00ff41;
      --scanline-opacity: 0.1;
    }
    
    /* ============================================
       BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: var(--bg-black);
      color: var(--matrix-green);
      font-family: 'Share Tech Mono', monospace;
      overflow-x: hidden;
      cursor: crosshair;
    }
    
    /* ============================================
       MATRIX RAIN CANVAS
       ============================================ */
    #matrix-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.8;
    }
    
    /* ============================================
       SCANLINE OVERLAY EFFECT
       ============================================ */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15),
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 2px
      );
      animation: scanline-flicker 0.1s infinite;
    }
    
    @keyframes scanline-flicker {
      0%, 100% { opacity: var(--scanline-opacity); }
      50% { opacity: calc(var(--scanline-opacity) + 0.05); }
    }
    
    /* ============================================
       GLITCH TEXT EFFECT - RGB SPLIT
       ============================================ */
    .glitch {
      position: relative;
      display: inline-block;
    }
    
    .glitch.active::before,
    .glitch.active::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.8;
    }
    
    .glitch.active::before {
      animation: glitch-anim-1 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
      color: var(--glitch-red);
      z-index: -1;
    }
    
    .glitch.active::after {
      animation: glitch-anim-2 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse both infinite;
      color: var(--neon-cyan);
      z-index: -2;
    }
    
    @keyframes glitch-anim-1 {
      0%, 100% {
        transform: translate(0);
      }
      33% {
        transform: translate(-2px, 2px);
      }
      66% {
        transform: translate(2px, -2px);
      }
    }
    
    @keyframes glitch-anim-2 {
      0%, 100% {
        transform: translate(0);
      }
      33% {
        transform: translate(2px, -2px);
      }
      66% {
        transform: translate(-2px, 2px);
      }
    }
    
    /* ============================================
       CURSOR BLINK ANIMATION
       ============================================ */
    .cursor {
      display: inline-block;
      width: 10px;
      height: 1em;
      background: var(--matrix-green);
      margin-left: 4px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }
    
    /* ============================================
       BUTTON STYLES - Cyberpunk aesthetic
       ============================================ */
    .cyber-button {
      position: relative;
      padding: 10px 24px;
      border: 2px solid var(--matrix-green);
      background: transparent;
      color: var(--matrix-green);
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.3s ease;
      clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    }
    
    .cyber-button:hover {
      background: var(--matrix-green);
      color: var(--bg-black);
      box-shadow: 0 0 20px var(--matrix-green);
    }
    
    .cyber-button.active {
      background: var(--matrix-green);
      color: var(--bg-black);
    }
    
    /* ============================================
       MODAL STYLES
       ============================================ */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .modal-content {
      width: 100%;
      max-width: 1200px;
      background: var(--bg-dark);
      border: 2px solid var(--matrix-green);
      padding: 20px;
      position: relative;
      animation: slideUp 0.3s ease;
    }
    
    @keyframes slideUp {
      from { transform: translateY(50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: none;
      color: var(--glitch-red);
      font-size: 30px;
      cursor: pointer;
      padding: 5px 10px;
      line-height: 1;
    }
    
    .modal-close:hover {
      color: var(--matrix-green);
      transform: rotate(90deg);
      transition: all 0.3s ease;
    }
    
    /* ============================================
       VIDEO THUMBNAIL GRID
       ============================================ */
    .video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      margin: 30px 0;
    }
    
    .video-card {
      background: rgba(0, 255, 65, 0.05);
      border: 1px solid var(--matrix-green);
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .video-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.3), transparent);
      transition: left 0.5s ease;
    }
    
    .video-card:hover::before {
      left: 100%;
    }
    
    .video-card:hover {
      border-color: var(--neon-cyan);
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
      transform: translateY(-5px);
    }
    
    .video-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      background: var(--bg-black);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
    }
    
    .video-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .play-icon {
      position: absolute;
      width: 60px;
      height: 60px;
      border: 3px solid var(--matrix-green);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      transition: all 0.3s ease;
    }
    
    .video-card:hover .play-icon {
      transform: scale(1.2);
      border-color: var(--neon-cyan);
      background: rgba(0, 255, 255, 0.2);
    }
    
    .play-icon::after {
      content: '';
      width: 0;
      height: 0;
      border-left: 20px solid var(--matrix-green);
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      margin-left: 5px;
    }
    
    /* ============================================
       TERMINAL INPUT STYLES
       ============================================ */
    .terminal-input {
      background: transparent;
      border: none;
      color: var(--matrix-green);
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      outline: none;
      width: 100%;
      padding: 5px;
    }
    
    .terminal-output {
      font-family: 'VT323', monospace;
      font-size: 18px;
      line-height: 1.4;
      margin-bottom: 10px;
    }
    
    /* ============================================
       NOISE/GRAIN TEXTURE OVERLAY
       ============================================ */
    .noise-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
      opacity: 0.03;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='4' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' /%3E%3C/svg%3E");
      animation: noise 0.2s infinite;
    }
    
    @keyframes noise {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-2%, -2%); }
      20% { transform: translate(2%, 2%); }
      30% { transform: translate(-2%, 2%); }
      40% { transform: translate(2%, -2%); }
      50% { transform: translate(-2%, -2%); }
      60% { transform: translate(2%, 2%); }
      70% { transform: translate(-2%, 2%); }
      80% { transform: translate(2%, -2%); }
      90% { transform: translate(-2%, -2%); }
    }
    
    /* ============================================
       MOBILE RESPONSIVE
       ============================================ */
    @media (max-width: 768px) {
      .video-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .cyber-button {
        padding: 8px 16px;
        font-size: 12px;
      }
      
      .modal-content {
        padding: 15px;
      }
    }
    
    /* ============================================
       LOADING TEXT ANIMATION
       ============================================ */
    @keyframes typing {
      from { width: 0; }
      to { width: 100%; }
    }
    
    .typing-text {
      overflow: hidden;
      white-space: nowrap;
      border-right: 2px solid var(--matrix-green);
      animation: typing 3s steps(40) 1s forwards, blink 0.75s step-end infinite;
    }
  </style>

</head>
<body>
  <!-- ============================================
       ROOT ELEMENT FOR REACT APP
       ============================================ -->
  <div id="root"></div>

  <!-- ============================================
       REACT APPLICATION - JSX CODE
       ============================================ -->

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // =============================================
    // MATRIX RAIN COMPONENT - Canvas Animation
    // Adjust columns, speed, and characters here
    // =============================================
    const MatrixRain = ({ intensity = 'normal' }) => {
      const canvasRef = useRef(null);
      const [isMobile, setIsMobile] = useState(window.innerWidth < 768);
      
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth < 768);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Matrix characters - Katakana, numbers, symbols
        const chars = 'ｦｱｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ<>[]{}|/\\@#$%^&*';
        const charArray = chars.split('');
        
        // Calculate column count based on device
        const fontSize = 16;
        const columnCount = isMobile ? 15 : Math.floor(canvas.width / fontSize);
        const drops = Array(columnCount).fill(1);
        
        // Draw function
        const draw = () => {
          // Fade effect for trail
          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Matrix green color
          ctx.fillStyle = '#00ff41';
          ctx.font = `${fontSize}px 'VT323', monospace`;
          
          // Draw characters
          drops.forEach((y, i) => {
            const text = charArray[Math.floor(Math.random() * charArray.length)];
            const x = i * fontSize;
            ctx.fillText(text, x, y * fontSize);
            
            // Reset drop randomly
            if (y * fontSize > canvas.height && Math.random() > 0.975) {
              drops[i] = 0;
            }
            
            drops[i]++;
          });
        };
        
        // Animation loop
        const interval = setInterval(draw, isMobile ? 50 : 33);
        
        // Handle window resize
        const handleResize = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', handleResize);
        
        return () => {
          clearInterval(interval);
          window.removeEventListener('resize', handleResize);
        };
      }, [isMobile, intensity]);

      return <canvas ref={canvasRef} id="matrix-canvas" />;
    };

    // =============================================
    // AUDIO SYSTEM - Glitch Beeps
    // =============================================
    const useAudioSystem = () => {
      const audioContextRef = useRef(null);
      
      const initAudio = useCallback(() => {
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        }
      }, []);
      
      const playGlitchBeep = useCallback(() => {
        initAudio();
        const ctx = audioContextRef.current;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        // Glitch sound parameters
        oscillator.frequency.value = Math.random() * 800 + 200;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        
        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + 0.1);
      }, [initAudio]);
      
      return { playGlitchBeep };
    };

    // =============================================
    // TEXT SCRAMBLE EFFECT HOOK
    // =============================================
    const useTextScramble = (text, trigger) => {
      const [scrambledText, setScrambledText] = useState(text);
      const chars = '!<>-_\\/[]{}—=+*^?#________';
      
      useEffect(() => {
        if (!trigger) return;
        
        let frame = 0;
        const queue = [];
        
        // Build queue
        for (let i = 0; i < text.length; i++) {
          const from = text[i];
          const to = text[i];
          const start = Math.floor(Math.random() * 20);
          const end = start + Math.floor(Math.random() * 20);
          queue.push({ from, to, start, end });
        }
        
        // Animation function
        const update = () => {
          let output = '';
          let complete = 0;
          
          queue.forEach((item, i) => {
            if (frame >= item.end) {
              output += item.to;
              complete++;
            } else if (frame >= item.start) {
              output += chars[Math.floor(Math.random() * chars.length)];
            } else {
              output += item.from || ' ';
            }
          });
          
          setScrambledText(output);
          
          if (complete === queue.length) {
            clearInterval(interval);
          }
          
          frame++;
        };
        
        const interval = setInterval(update, 30);
        
        return () => clearInterval(interval);
      }, [text, trigger]);
      
      return scrambledText;
    };

    // =============================================
    // VIDEO MODAL COMPONENT
    // =============================================
    const VideoModal = ({ video, onClose }) => {
      useEffect(() => {
        document.body.style.overflow = 'hidden';
        return () => {
          document.body.style.overflow = 'unset';
        };
      }, []);
      
      if (!video) return null;
      
      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <button className="modal-close" onClick={onClose}>&times;</button>
            <h2 className="text-2xl font-bold mb-4" style={{ fontFamily: 'Orbitron' }}>
              {video.title}
            </h2>
            <div style={{ position: 'relative', paddingBottom: '56.25%', height: 0 }}>
              <iframe
                src={`https://www.youtube.com/embed/${video.id}`}
                style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowFullScreen
              />
            </div>
            <p className="mt-4 text-sm">{video.description}</p>
          </div>
        </div>
      );
    };

    // =============================================
    // VIDEO CARD COMPONENT
    // =============================================
    const VideoCard = ({ video, onClick, onGlitch }) => {
      const [isGlitching, setIsGlitching] = useState(false);
      
      const handleClick = () => {
        setIsGlitching(true);
        onGlitch();
        setTimeout(() => {
          setIsGlitching(false);
          onClick(video);
        }, 300);
      };
      
      return (
        <div 
          className={`video-card ${isGlitching ? 'glitch active' : ''}`}
          onClick={handleClick}
          data-text={video.title}
        >
          <div className="video-thumbnail">
            <img 
              src={`https://img.youtube.com/vi/${video.id}/maxresdefault.jpg`}
              alt={video.title}
              onError={(e) => {
                e.target.src = `https://img.youtube.com/vi/${video.id}/hqdefault.jpg`;
              }}
            />
            <div className="play-icon" />
          </div>
          <h3 className="font-bold mb-2" style={{ fontFamily: 'Orbitron' }}>
            {video.title}
          </h3>
          <p className="text-xs opacity-70">{video.description}</p>
        </div>
      );
    };

    // =============================================
    // MAIN APP COMPONENT
    // =============================================
    const App = () => {
      const [currentSection, setCurrentSection] = useState('home');
      const [isTerminalMode, setIsTerminalMode] = useState(false);
      const [terminalInput, setTerminalInput] = useState('');
      const [terminalHistory, setTerminalHistory] = useState([]);
      const [selectedVideo, setSelectedVideo] = useState(null);
      const [titleGlitch, setTitleGlitch] = useState(false);
      const [showCursor, setShowCursor] = useState(true);
      
      const { playGlitchBeep } = useAudioSystem();
      const scrambledTitle = useTextScramble('ACCESS GRANTED: N1X', true);
      
      // ============================================
      // VIDEO DATA - Replace with your actual YouTube video IDs
      // Get video IDs from YouTube URLs after /watch?v=
      // ============================================
      const videoData = {
        synths: [
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER - Replace with actual video ID
            title: 'SYNTHETIC_DREAMS_01',
            description: 'Pure AI generation - Neural synthesis experiment'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER - Replace with actual video ID
            title: 'DIGITAL_VOID_02',
            description: 'Machine learning composition - Algorithmic soundscape'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER - Replace with actual video ID
            title: 'CYBERSPACE_03',
            description: 'AI-driven ambient - Binary consciousness'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER - Replace with actual video ID
            title: 'NEURAL_NETWORK_04',
            description: 'Artificial intelligence audio generation'
          }
        ],
        analogues: [
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'HUMAN_TOUCH_01',
            description: '100% organic creation - Pure human composition'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'ANALOG_WAVES_02',
            description: 'Traditional instruments - Human performance'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'ACOUSTIC_SOUL_03',
            description: 'Handcrafted soundscapes - No AI involved'
          }
        ],
        hybrids: [
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'FUSION_PROTOCOL_01',
            description: 'Human creativity + AI enhancement - Perfect synthesis'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'SYMBIOTIC_02',
            description: 'Collaborative creation - Man and machine united'
          },
          {
            id: 'dQw4w9WgXcQ', // PLACEHOLDER
            title: 'HYBRID_CONSCIOUSNESS_03',
            description: 'Augmented composition - Enhanced by AI'
          }
        ]
      };
      
      // Initial glitch effect on mount
      useEffect(() => {
        setTitleGlitch(true);
        const timer = setTimeout(() => setTitleGlitch(false), 2000);
        return () => clearTimeout(timer);
      }, []);
      
      // Cursor blink
      useEffect(() => {
        const interval = setInterval(() => {
          setShowCursor(prev => !prev);
        }, 530);
        return () => clearInterval(interval);
      }, []);
      
      // Terminal command handler
      const handleTerminalCommand = (e) => {
        e.preventDefault();
        const command = terminalInput.toLowerCase().trim();
        
        playGlitchBeep();
        
        const newHistory = [...terminalHistory, `root@n1x:~$ ${terminalInput}`];
        
        if (command === 'home' || command === 'goto home') {
          setCurrentSection('home');
          newHistory.push('> Navigating to HOME...');
        } else if (command === 'analogues' || command === 'goto analogues') {
          setCurrentSection('analogues');
          newHistory.push('> Loading ANALOGUES section...');
        } else if (command === 'synths' || command === 'goto synths') {
          setCurrentSection('synths');
          newHistory.push('> Loading SYNTHS section...');
        } else if (command === 'hybrids' || command === 'goto hybrids') {
          setCurrentSection('hybrids');
          newHistory.push('> Loading HYBRIDS section...');
        } else if (command === 'help') {
          newHistory.push('> Available commands: home, analogues, synths, hybrids, clear, help');
        } else if (command === 'clear') {
          setTerminalHistory([]);
          setTerminalInput('');
          return;
        } else if (command === '') {
          // Do nothing for empty command
        } else {
          newHistory.push(`> Command not found: ${command}`);
          newHistory.push('> Type "help" for available commands');
        }
        
        setTerminalHistory(newHistory);
        setTerminalInput('');
      };
      
      // Section change handler with glitch
      const changeSection = (section) => {
        setTitleGlitch(true);
        playGlitchBeep();
        setTimeout(() => {
          setCurrentSection(section);
          setTitleGlitch(false);
        }, 300);
      };
      
      // Section content renderer
      const renderSectionContent = () => {
        const sections = {
          home: {
            title: 'N1X_SYSTEM',
            subtitle: 'CYBORG_CREATOR > AUDIO_VISUAL_SYNTHESIS',
            description: 'Exploring the convergence of human creativity and artificial intelligence through sound and vision. Three distinct streams of consciousness: Pure human (ANALOGUES), Pure machine (SYNTHS), and their synthesis (HYBRIDS).',
            footer: 'INITIALIZE_PROTOCOL > SELECT_STREAM'
          },
          analogues: {
            title: 'ANALOGUES',
            subtitle: 'HUMAN_ORIGIN > 100%_ORGANIC',
            description: 'Pure human creativity. No artificial enhancement. Raw artistic expression from biological consciousness. Traditional composition, performance, and production.',
            footer: `${videoData.analogues.length} ORGANIC_TRACKS_AVAILABLE`
          },
          synths: {
            title: 'SYNTHS',
            subtitle: 'AI_ORIGIN > PURE_SYNTHESIS',
            description: 'Generated by artificial intelligence. Machine learning algorithms composing, producing, and creating without human intervention. Pure digital consciousness.',
            footer: `${videoData.synths.length} SYNTHETIC_TRACKS_AVAILABLE`
          },
          hybrids: {
            title: 'HYBRIDS',
            subtitle: 'HUMAN+AI > COLLABORATIVE_FUSION',
            description: 'The synthesis of human and machine. Human creativity enhanced and augmented by artificial intelligence. The future of artistic collaboration.',
            footer: `${videoData.hybrids.length} HYBRID_TRACKS_AVAILABLE`
          }
        };
        
        const section = sections[currentSection];
        const videos = videoData[currentSection] || [];
        
        return (
          <div className="relative z-10 min-h-screen flex flex-col">
            {/* Header */}
            <div className="p-6 md:p-10">
              <h1 
                className={`text-4xl md:text-7xl font-bold mb-4 glitch ${titleGlitch ? 'active' : ''}`}
                data-text={scrambledTitle}
                style={{ fontFamily: 'Orbitron' }}
              >
                {scrambledTitle}
              </h1>
              
              {/* Navigation Toggle */}
              <div className="flex items-center gap-4 mb-6">
                <span className="text-sm opacity-70">NAV_MODE:</span>
                <button
                  className="cyber-button text-xs"
                  onClick={() => {
                    setIsTerminalMode(!isTerminalMode);
                    playGlitchBeep();
                  }}
                >
                  {isTerminalMode ? 'TABS' : 'TERMINAL'}
                </button>
              </div>
              
              {/* Tab Navigation */}
              {!isTerminalMode && (
                <div className="flex flex-wrap gap-4 mb-6">
                  {['home', 'analogues', 'synths', 'hybrids'].map((tab) => (
                    <button
                      key={tab}
                      className={`cyber-button ${currentSection === tab ? 'active' : ''}`}
                      onClick={() => changeSection(tab)}
                    >
                      {tab}
                    </button>
                  ))}
                </div>
              )}
              
              {/* Terminal Mode */}
              {isTerminalMode && (
                <div className="bg-black bg-opacity-80 border-2 border-green-500 p-4 mb-6 max-h-60 overflow-y-auto">
                  {terminalHistory.map((line, i) => (
                    <div key={i} className="terminal-output">{line}</div>
                  ))}
                  <form onSubmit={handleTerminalCommand} className="flex items-center">
                    <span className="text-green-500 mr-2">root@n1x:~$</span>
                    <input
                      type="text"
                      value={terminalInput}
                      onChange={(e) => setTerminalInput(e.target.value)}
                      className="terminal-input"
                      placeholder="Enter command (type 'help' for options)"
                      autoFocus
                    />
                    {showCursor && <span className="cursor" style={{ width: '8px', height: '18px' }} />}
                  </form>
                </div>
              )}
            </div>
            
            {/* Section Content */}
            <div className="flex-1 px-6 md:px-10 pb-10">
              <div className="mb-8">
                <h2 className="text-3xl md:text-5xl font-bold mb-2" style={{ fontFamily: 'Orbitron' }}>
                  [{section.title}]
                </h2>
                <p className="text-sm md:text-base opacity-80 mb-4">{section.subtitle}</p>
                <p className="text-sm md:text-base max-w-3xl">{section.description}</p>
              </div>
              
              {/* Video Grid */}
              {videos.length > 0 && (
                <div className="video-grid">
                  {videos.map((video, index) => (
                    <VideoCard
                      key={index}
                      video={video}
                      onClick={setSelectedVideo}
                      onGlitch={playGlitchBeep}
                    />
                  ))}
                </div>
              )}
              
              {/* Footer */}
              <div className="mt-10 text-center opacity-50 text-sm">
                <p>{section.footer}</p>
                <p className="mt-2">↑↑↓↓←→←→BA_START</p>
              </div>
            </div>
          </div>
        );
      };
      
      return (
        <>
          <MatrixRain />
          <div className="scanlines" />
          <div className="noise-overlay" />
          
          {renderSectionContent()}
          
          {selectedVideo && (
            <VideoModal
              video={selectedVideo}
              onClose={() => {
                setSelectedVideo(null);
                playGlitchBeep();
              }}
            />
          )}
        </>
      );
    };

    // =============================================
    // RENDER APP TO DOM
    // =============================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>

</body>
</html>
